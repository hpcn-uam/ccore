

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>C parser module documentation</title>
  
 
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  
  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> CCORE</a>

              <div class="version">
                1.0.6
              </div>
          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">

<li class="toctree-l1 current"><a class="current reference internal" href="">C parser module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-documentation">Class documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-does-it-work">How does it work</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filtering">Filtering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-new-types">Adding new types</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">FERMIN</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>C parser module</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/cparser.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="c-parser-module">
<h1>C parser module<a class="headerlink" href="#c-parser-module" title="Permalink to this headline">¶</a></h1>

<p>This module was first developed for the project <a target="_blank" href="http://www.naudit.es/en/fermin/">FERMIN</a> aiming to improve speed and memory footprint of the reading operations. This reading operations were performed over text files with enriched records obtained from network dissector tools. Afterwards, high level python parsers process their content for multiple and diverse analysis purposes. The examples described in the following document refer to these dissector parsers as the upper objects who make use of the ccore, but we note that this module could be used for any other kind of text file.</p>

<p>To improve speed and memory footprint, the dissector parsers can use the C parser module to read from files. It also provides functions that will improve performance of filtering and timeseries generation.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>First, the <a class="reference internal" href="#cparser.RecordList" title="cparser.RecordList"><code class="xref py py-class docutils literal"><span class="pre">cparser.RecordList</span></code></a> object must be created, and then the <a class="reference internal" href="#cparser.RecordList.read" title="cparser.RecordList.read"><code class="xref py py-func docutils literal"><span class="pre">cparser.RecordList.read()</span></code></a> method called with the appropiate parameters.</p>
<p>Once all the values are read from the file and saved in the corresponding blocks after calling the read method, the records can be accessed. The <a class="reference internal" href="#cparser.RecordList" title="cparser.RecordList"><code class="xref py py-class docutils literal"><span class="pre">cparser.RecordList</span></code></a> class exposes list methods, so it can be accessed by index or iterated over.</p>
<p>The elements of the list are actually an internal type that only haves the index of the record. However, when attributes of the record are accessed, the type builds the Python objects on demand and returns them to the caller, so the implementation details are transparent to the user and the record behaves like any other Python class.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cparser</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="s1">&#39;file.dat&#39;</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">cparser</span><span class="o">.</span><span class="n">RecordList</span><span class="p">()</span>  <span class="c1"># Create the parser</span>

<span class="c1"># Dictionary with the parameters of the file.</span>
<span class="c1"># The keys are the field names, and the values are tuples</span>
<span class="c1"># with the field specification: the column index, the type and,</span>
<span class="c1"># optionally, a function to convert the value from the text.</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;srcMAC&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">),</span>
        <span class="s1">&#39;dstMAC&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">),</span>
        <span class="s1">&#39;frames&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">),</span>
        <span class="s1">&#39;bytes&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">),</span>
        <span class="s1">&#39;ts_start&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;double&#39;</span><span class="p">),</span>
        <span class="s1">&#39;ts_end&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;double&#39;</span><span class="p">),</span>
        <span class="s1">&#39;is_vlan&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">word</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Functions can be used to calculate values to store depending on the column value.</span>
<span class="p">}</span>

<span class="n">parser</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
<span class="n">num_iterated</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">parser</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">record</span><span class="o">.</span><span class="n">srcMAC</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">dstMC</span>

<span class="k">print</span> <span class="n">parser</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">srcMAC</span>

<span class="n">vlan_records</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">filter_fields</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="s1">&#39;is_vlan&#39;</span><span class="p">)</span>  <span class="c1"># Get all records with VLAN</span>
<span class="n">frames</span> <span class="o">=</span> <span class="n">vlan_records</span><span class="o">.</span><span class="n">field_as_numpy</span><span class="p">(</span><span class="s1">&#39;frames&#39;</span><span class="p">)</span>  <span class="c1"># Get a numpy array of all the frames</span>
</pre></div>
</div>
<p>See the <em>test_cparser.py</em> test file for examples.</p>
</div>
<div class="section" id="class-documentation">
<h2>Class documentation<a class="headerlink" href="#class-documentation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cparser.RecordList">
<em class="property">class </em><code class="descclassname">cparser.</code><code class="descname">RecordList</code><a class="headerlink" href="#cparser.RecordList" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="cparser.RecordList.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>timezone = None</em>, <em>separator = &quot; &quot;</em><span class="sig-paren">)</span><a class="headerlink" href="#cparser.RecordList.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the recordlist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>timezone</strong> &#8211; If not none, the Pandas timestamps will be created with this timezone.</li>
<li><strong>separator</strong> &#8211; String with the field separator. Defaults to &#8216; &#8216; (space). Note that cparser behaves like awk regarding separator: multiple separators are ignored only when they are spaces or tabs, not when they are other character. For example, <code class="docutils literal"><span class="pre">hello</span>&nbsp;&nbsp;&nbsp; <span class="pre">world</span></code> is counted as two fields even when there are multiple spaces separating them, but <code class="docutils literal"><span class="pre">`hello||world`</span></code> with | as separator is counted as three fields.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cparser.RecordList.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>fpath</em>, <em>field_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#cparser.RecordList.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads and parses the file, storing the fields in internal C structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fpath</strong> &#8211; Path to the file to parse.</li>
<li><strong>field_dict</strong> &#8211; <p>Dictionary with the fields to parse, where the keys are the field    names and the values are tuples (column_index, type, [func]). Type is a string containing one of the following types:</p>
<blockquote>
<div><ul>
<li><em>int</em></li>
<li><em>string</em></li>
<li><em>double</em></li>
<li><em>ip</em>. The parser reads an IP and converts it to an integer. The Python object returned is the same integer.</li>
<li><em>tstamp</em>. The parser reads and stores a double value. The returned Python object is a Pandas.Timestamp object.</li>
<li><em>bool</em>. The parser reads an integer. The Python object returned is a <em>bool</em> object (either True or False).</li>
</ul>
</div></blockquote>
<p>Func is an optional value in the tuple. If present, it should be a function (or a lambda) that receives the word in the column and returns a value of the appropiate type to be stored.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cparser.RecordList.tstamp_range">
<code class="descname">tstamp_range</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>fields</em><span class="sig-paren">)</span><a class="headerlink" href="#cparser.RecordList.tstamp_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an iterator that will only return records where at least one of the indicated fields is in the time range start-end.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>start</strong> &#8211; pandas.Timestamp of the range start.</li>
<li><strong>end</strong> &#8211; pandas.Timestamp of the range start.</li>
<li><strong>fields</strong> &#8211; List of fields (strings) that should be compared with the start/end times.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cparser.RecordList.field_as_numpy">
<code class="descname">field_as_numpy</code><span class="sig-paren">(</span><em>field</em>, <em>default_tstamp</em><span class="sig-paren">)</span><a class="headerlink" href="#cparser.RecordList.field_as_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return in a Numpy array all the values of &#8216;field&#8217; of the records. Especially useful for quick generation of timeseries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>field</strong> (<em>string</em>) &#8211; Name of the field to put in the array.</li>
<li><strong>default_tstamp</strong> (<em>pandas.Timestamp</em>) &#8211; Default timestamp if the field is a timestamp with value 0.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Numpy array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cparser.RecordList.filter_fields">
<code class="descname">filter_fields</code><span class="sig-paren">(</span><em>value</em>, <em>fields</em><span class="sig-paren">)</span><a class="headerlink" href="#cparser.RecordList.filter_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an interator that will only show records where at least one of the fields matches the given value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>value</strong> &#8211; Value to filter by.</li>
<li><strong>fields</strong> (<em>List of strings</em>) &#8211; Fields that will be checked. All of them must be of the
same type.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Iterator with the corresponding filters configured.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cparser.RecordList.min_timestamp">
<code class="descname">min_timestamp</code><a class="headerlink" href="#cparser.RecordList.min_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum pandas.Timestamp value seen in the parsing. Timestamps values below 0 are ignored.</p>
</dd></dl>

<dl class="attribute">
<dt id="cparser.RecordList.max_timestamp">
<code class="descname">max_timestamp</code><a class="headerlink" href="#cparser.RecordList.max_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum pandas.Timestamp value seen in the parsing, or 0 if no one was found. Timestamps values below 0 are ignored.</p>
</dd></dl>

<dl class="attribute">
<dt id="cparser.RecordList.tz">
<code class="descname">tz</code><a class="headerlink" href="#cparser.RecordList.tz" title="Permalink to this definition">¶</a></dt>
<dd><p>Timezone in which the parser is configured in.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="how-does-it-work">
<h2>How does it work<a class="headerlink" href="#how-does-it-work" title="Permalink to this headline">¶</a></h2>
<p>This module, placed in <em>hpat/ccore</em>, reads the fields from the file and stores them in several blocks. Each block has one array for each possible field type (currently, strings, integers and doubles), where all the field values are stored.</p>
<p>Each field of the parser is represented by a <em>field_spec</em> structure, defined in the <em>cparser.h</em> file. This structure defines four properties: the column index, the type, the name and the type index. The type index is the property that allows direct access to any field of any given record. For example, when parsing records with four fields, two integers and two strings, the first two integers would get type indexes 0 and 1 respectively. The two strings would get also type indexes 0 and 1, because they are respectively the first and second fields of type string in a record.</p>
<p>Thus, to access to an integer field with type index 2 in the record number 19823, we would have the following code:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">record_index</span> <span class="o">=</span> <span class="mi">19823</span>
<span class="n">type_index</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">block_index</span> <span class="o">=</span> <span class="mi">19832</span> <span class="o">/</span> <span class="n">records_per_block</span>
<span class="n">record_in_block_index</span> <span class="o">=</span> <span class="n">record_index</span> <span class="o">%</span> <span class="n">record_per_block</span>
<span class="n">offset_in_array</span> <span class="o">=</span> <span class="n">fields_per_record</span><span class="p">[</span><span class="n">integers</span><span class="p">]</span> <span class="o">*</span> <span class="n">record_in_block_index</span> <span class="o">+</span> <span class="n">type_index</span>

<span class="n">value</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="n">block_index</span><span class="p">].</span><span class="n">fields</span><span class="p">[</span><span class="n">integers</span><span class="p">][</span><span class="n">offset_in_array</span><span class="p">]</span>
</pre></div>
</div>
<p>When a specific record is requested (either by iteration or by index access), the object returned is just a struct (<em>cparser_record</em> C type in <em>cparser-python.c</em>) holding a reference to the list and the index of the record. When a specific attribute is requested, the overridden <em>__getattr__</em> function is called, which gets the corresponding value as specified above and then builds the Python object on demand. Thus, only fields that are actually used are built, saving huge amounts of memory and computing.</p>
</div>
<div class="section" id="filtering">
<h2>Filtering<a class="headerlink" href="#filtering" title="Permalink to this headline">¶</a></h2>
<p>In order to improve performance, the cparser implements simple filters that are computed in the C module. These are filters by range (tstamp_range) and by field equality (filter_fields). Both functions return an iterator on which further filters may be applied (only one of each type) and run utility functions such as field_as_numpy to quickly get values from records.</p>
</div>
<div class="section" id="adding-new-types">
<h2>Adding new types<a class="headerlink" href="#adding-new-types" title="Permalink to this headline">¶</a></h2>
<p>Each type is described by a <em>rd_type</em> structure, that contains the following fields:</p>
<ul class="simple">
<li><em>type</em>: The type identifier, a value from the <em>rd_types</em> enum.</li>
<li><em>storage_type</em>: The type of the underlying variable used to store the field. For example, a timestamp may be saved in a variable of type double. It is a value from the <em>rd_base_types</em> enum.</li>
<li><em>read</em>: A pointer to a function that receives a string (the field to parse) and a pointer to the location where the field should be saved.</li>
<li><em>to_python</em>: A pointer to a function that receives the pointer to the value and its size, and returns the corresponding Python object.</li>
<li><em>from_python</em>: A pointer to a function that receives the PyObject* and stores the correspnding C value. Needed when optional reader functions are used.</li>
<li><em>has_variable_size</em>: Decides if this field has fixed size (numeric values) or not (strings). If it has variable size, the <em>read</em> function can be NULL: the <em>read_table</em> function will instead save the address of beginning of the field in the field storage, and will also save the length of the field. See the function <em>python_str</em> in <em>cparser-python.c</em> for an example of how these fields are managed.</li>
<li><em>name</em>: The name of the type, so it can be identified from the Python code.</li>
</ul>
<p>In order to add new types, one should add its identifier to the <em>rd_types</em> enum in <em>cparser.h</em>, create the functions to read the value from a string and to build the Python object (you can see some examples in the read_* and python_* functions in <em>cparser-python.c</em>), and finally register the type using the function <em>add_type</em>, which receives the fields of the <em>rd_type</em> structure in the same order as in the above list.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Naudit - HPCN.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.6',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>